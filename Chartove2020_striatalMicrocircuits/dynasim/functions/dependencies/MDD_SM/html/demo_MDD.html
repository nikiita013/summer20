
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Multidimensional Dictionary - Demo</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-25"><meta name="DC.source" content="demo_MDD.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Multidimensional Dictionary - Demo</h1><!--introduction--><p>File demonstrating some of the basic capabilities of MDD on a sample neuroscience dataset. For full instructions on using MDD, see tutorial_MDD.m</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Overview</a></li><li><a href="#2">Set up paths and formatting</a></li><li><a href="#3">Load a sample dataset and build an MDD object</a></li><li><a href="#8">What is an MDD object and why use one?</a></li><li><a href="#14">MDD subscripts and indexing</a></li><li><a href="#21">Advanced indexing methods</a></li><li><a href="#23">Running functions on MDD objects</a></li><li><a href="#27">Plotting 3D data</a></li><li><a href="#36">Modularization of plotting</a></li><li><a href="#42">Merging two MDD objects</a></li><li><a href="#46">Packing MDD dimensions (analogous to cell2mat)</a></li><li><a href="#52">Unpacking MDD dimensions</a></li><li><a href="#56">Next steps</a></li><li><a href="#57">Summary so far</a></li></ul></div><h2 id="1">Overview</h2><p>MDD is a MATLAB tool for managing high-dimensional data that often arises in scientific data analysis. It can be thoughout of as a MATLAB cell array (or matrix) with some additional functionality.</p><h2 id="2">Set up paths and formatting</h2><pre class="codeinput"><span class="comment">% Format</span>
format <span class="string">compact</span>
format <span class="string">short</span> <span class="string">g</span>

<span class="comment">% Check if in MDD folder</span>
<span class="keyword">if</span> ~exist(fullfile(<span class="string">'.'</span>,<span class="string">'data'</span>,<span class="string">'sample_data.mat'</span>), <span class="string">'file'</span>)
    error(<span class="string">'Should be in MDD folder to run this code.'</span>)
<span class="keyword">end</span>

<span class="comment">% Add MDD toolbox to Matlab path if needed</span>
<span class="keyword">if</span> ~exist(<span class="string">'MDD'</span>,<span class="string">'class'</span>)
  addpath(genpath(pwd));
<span class="keyword">end</span>
</pre><h2 id="3">Load a sample dataset and build an MDD object</h2><pre class="codeinput"><span class="comment">% Load some sample simulated data</span>
load(<span class="string">'sample_data.mat'</span>);
load(<span class="string">'sample_data_meta2.mat'</span>);
</pre><p>The file <i>sample_data.mat</i> contains <i>dat</i>, a 4-dimensional cell array:</p><pre class="codeinput">whos <span class="string">dat</span>
</pre><pre class="codeoutput">  Name      Size                  Bytes  Class    Attributes

  dat       3x3x2x8            21633984  cell               

</pre><p>Each cell in dat contains some neural time series data. For example</p><pre class="codeinput">dat(1,1,2,1)
</pre><pre class="codeoutput">ans =
  1&times;1 cell array
    {1001&times;20 single}
</pre><p>Use this to build an MDD object.</p><pre class="codeinput"><span class="comment">% Construct MDD object</span>
mdd = MDD(dat,axis_vals,axis_names);
</pre><p>Note that <i>axis_vals</i> and <i>axis_names</i> contain useful metadata, but their details are not important here.</p><h2 id="8">What is an MDD object and why use one?</h2><p>When working with high-dimensional data, like that cell array <i>dat</i>, it's often difficult to keep track of what each dimension represents. <b>MDD objects provide a way of organizing and manipulating this information.</b></p><p>Let's print a summary of the data contained within <i>mdd</i>:</p><pre class="codeinput"><span class="comment">% Print object summary</span>
mdd.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  2  8]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n, I_iGABAa_s, E_iAMPA_s, I_iGABAa_ISYN, E_iAMPA_ISYN
</pre><p>This tells us several things about our MDD object:</p><div><ul><li>It is a 4-dimensional object with mdd.size = [3,3,2,8]</li><li>The four axes are titled: param1, param2, populations, and variables</li><li>This also summarizes the values that each axis takes on, and the corresponding data type of those values (numeric or cellstr). For example, the 'populations' axis takes on values 'E' and 'I' (for excitatory and inhibitory cells, respectively).</li></ul></div><p>An MDD object can be thought of in several ways:</p><div><ul><li>A MATLAB matrix or cell array that can be indexed by using strings and regular expressions</li><li>An N-dimensional table (a table is equivalent to an MDD object in 2-dimensions)</li><li>A map/dictionary that associates multiple keys with a single value</li></ul></div><h2 id="14">MDD subscripts and indexing</h2><p>MDD contains several options for how to index data. The most basic method is to just index MDD objects like you would index normal Matlab matrices and cells. For example:</p><pre class="codeinput"><span class="comment">% Basic indexing</span>
mdd3D = mdd(:,:,1,2:3);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  1  2]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: populations (cellstr) -&gt; E
Axis 4: variables (cellstr) -&gt; iNa_m, iNa_h
</pre><p>This selects everything from dimensions 1 and 2, the 1st element from dimension 3, and the 2nd and 3rd elements from dimension 4. Another way to do this, however, is to reference the axis values directly. For example:</p><pre class="codeinput"><span class="comment">% Indexing by string query</span>
mdd3D = mdd(:,:,<span class="string">'E'</span>,<span class="string">'iNa'</span>);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  1  2]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: populations (cellstr) -&gt; E
Axis 4: variables (cellstr) -&gt; iNa_m, iNa_h
</pre><p>Note that substring matching (based on Matlab's strcmp command) was used here to select both iNa_m and iNa_h. However, regular expressions can be used as well. The "/" denotes to use regular expressions for the search. This command picks out all variable names beginning with an "I".</p><pre class="codeinput"><span class="comment">% Indexing by regular expressions</span>
mdd3D = mdd(:,:,<span class="string">'E'</span>,<span class="string">'/^I/'</span>);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  1  2]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: populations (cellstr) -&gt; E
Axis 4: variables (cellstr) -&gt; I_iGABAa_s, I_iGABAa_ISYN
</pre><p>If we only want to specify the values for a single axis, we can use axisSubset. This indexes the 'variables' axis for all values containing 'iNa'</p><pre class="codeinput"><span class="comment">% Indexing by axis-value pairs</span>
mdd3D = mdd.axisSubset(<span class="string">'variables'</span>, <span class="string">'iNa'</span>);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  2  2]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; iNa_m, iNa_h
</pre><p>All standard forms of Matlab indexing work as well, including indexing by position, linear indexing, and logical indexing.</p><pre class="codeinput"><span class="comment">% Method 1 - Indexing by position</span>
foo1 = mdd(1:3,3,2,8);

<span class="comment">% Method 2 - Linear indexing</span>
foo2 = mdd(142:144);      <span class="comment">% Take the last 3 entries in the data.</span>

<span class="comment">% Method 3 - Logical indexing</span>
ind = false(1,144); ind(142:144) = true;
foo3 = mdd(ind);            <span class="comment">% Using logical indexing also produces the same result.</span>

disp(isequal(foo1,foo2,foo3));
clear <span class="string">foo1</span> <span class="string">foo2</span> <span class="string">foo3</span>
</pre><pre class="codeoutput">   1
</pre><p>The results of all three indexing methods above are the same. For more details about indexing methods in Matlab, see: <a href="https://www.mathworks.com/help/matlab/math/array-indexing.html">https://www.mathworks.com/help/matlab/math/array-indexing.html</a></p><h2 id="21">Advanced indexing methods</h2><p>Finally, MDD supports inline queries using the valSubset method. Here are two examples.</p><pre class="codeinput"><span class="comment">% Select axis1 values greater than 5, and axis2 equal to 10</span>
mdd3D = mdd.valSubset(<span class="string">'&gt;5'</span>,<span class="string">'==10'</span>,:,:);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [2  1  2  8]
Axis 1: param1 (numeric) -&gt; 10, 20
Axis 2: param2 (numeric) -&gt; 10
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n, I_iGABAa_s, E_iAMPA_s, I_iGABAa_ISYN, E_iAMPA_ISYN
</pre><pre class="codeinput"><span class="comment">% Select axis1 values between 8 and 11, and axis2 values between 3 and 11</span>
mdd3D = mdd.valSubset(<span class="string">'8 &lt; x &lt; 11'</span>,<span class="string">'3 &lt; x &lt;= 11'</span>,:,:);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [1  2  2  8]
Axis 1: param1 (numeric) -&gt; 10
Axis 2: param2 (numeric) -&gt; 5, 10
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n, I_iGABAa_s, E_iAMPA_s, I_iGABAa_ISYN, E_iAMPA_ISYN
</pre><h2 id="23">Running functions on MDD objects</h2><p>The primary purpose of MDD is to make working with high-dimensional data more convenient. Traditionally, if you are working with an N-dimensional matrix/cell array, you would write a function that takes in that variable and knows what to do with each of the N dimensions (usually involving nested for loops). This function would not work on data with N-1 or N+1 dimensions.</p><p>MDD takes a different approach. With MDD, you specify function handles that operate on lower dimensional data (usually 1D, 2D, or 3D) and to "assign" these to specific dimension in your higher dimensional MDD object. The MDD method <b>recursiveFunc</b> is used for this. Examples below will show how recursiveFunc can be used for plotting. But it is not limited to this.</p><p><b>Plotting setup</b></p><p>This section can be safely ignored. Here I'm just adding a metadata structure to our mdd object, which will be used by some of the following plotting commands. This stores some additional metadata about the time series in <i>mdd</i>. I'm also defining a data structure defining how large to make the figures.</p><pre class="codeinput">meta = struct;
meta.datainfo(1:2) = MDDAxis;
meta.datainfo(1).name = <span class="string">'time(ms)'</span>;
meta.datainfo(1).values = time;
meta.datainfo(2).name = <span class="string">'cells'</span>;
meta.datainfo(2).values = [];
mdd.meta = meta;
clear <span class="string">meta</span>

op.figwidth=0.4;
op.figheight=0.3;
</pre><h2 id="27">Plotting 3D data</h2><p>The workhorse of performing functions on MDD objects is <b>recursiveFunc</b>. Here is an example of how it is used to plot our data.</p><p>First, we will pull out a 3D subset of the data. Our data consists of 9 simulations of a neural network, in the form of a 3x3 parameter sweep (axes 1 and 2). For each simulation, we have data for the two different types of neurons simulated,  excitatory (E) and inhibitory (I) cells. We also have the variables associated with each neuron (for example, membrane voltage, ionic currents, etc.). Here, we will only look at the voltage of the neurons.</p><pre class="codeinput"><span class="comment">% Pull out a 3D MDD object with only E cell membrane voltage</span>
mdd3D = mdd(:,1:2,:,<span class="string">'v'</span>);
mdd3D.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  2  2  1]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v
</pre><p>Now, let's run the plot:</p><pre class="codeinput"><span class="comment">% Set up plotting arguments</span>
function_handles = {@xp_handles_fignew,@xp_subplot_grid,@xp_matrix_basicplot};
dimensions = {{<span class="string">'populations'</span>},{<span class="string">'param1'</span>,<span class="string">'param2'</span>},{<span class="string">'data'</span>}};
function_arguments = {{op},{},{}};

<span class="comment">% Run the plot. Note the "+" icons next to each plot allow zooming.</span>
close <span class="string">all</span>
mdd3D.recursiveFunc(function_handles,dimensions,function_arguments);
</pre><p>To break down what's going on here:</p><div><ul><li><i>function_handles</i> - A cell array of function handles that specify what to do with specific dimensions of the data.</li><li><i>dimensions</i> - A cell array that tells which dimensions of the data should be assigned to which function handles.</li><li><i>function_arguments</i> - A cell array that tells what arguments to pass to each of the function handles. Here we pass <i>op</i>, which tells xp_handles_fignew how big to make the figure.</li><li>There should be 1 entry in <i>dimensions</i> and <i>function_arguments</i> for every function handle supplied. (E.g., their lengths should be equal)</li></ul></div><p>In this example, the 'populations' dimension of our data (either E cells or I cells) is handled by the function <i>xp_handles_fignew</i>, which creates a new figure for each value along this dimension provided. The dimensions 'param1' and 'param2' are handled by xp_subplot_grid, which creates a grid of subplots for the parameter sweep. Note that xp_subplot_grid operates on 2D data. Finally, xp_matrix_basicplot creates the actual plots, operating on the time series data contained in <i>mdd.data</i></p><p>Here is the result:</p><img vspace="5" hspace="5" src="demo_MDD_01.png" alt=""> <img vspace="5" hspace="5" src="demo_MDD_02.png" alt=""> <p>Note that each of the functions passed to <i>function_handles</i> is essentially acting on lower-dimensional MDD objects. For example, xp_matrix_basicplot operates on 0D data (e.g., a single cell)</p><pre class="codeinput"><span class="comment">% Call xp_matrix_basicplot directly with 0D data (e.g.,</span>
foo = mdd(1,1,2,1);
close <span class="string">all</span>
figure; xp_matrix_basicplot(foo);
</pre><p>Similarly, xp_subplot_grid operates on 2D data, but it can only sets up the subplots and cannot plot anything. It needs recursiveFunc to chain everything together.</p><img vspace="5" hspace="5" src="demo_MDD_03.png" alt=""> <h2 id="36">Modularization of plotting</h2><p>The advantage of recursiveFunc is that the function handles we use can be recycled and applied in different contexts. This allows us to work with data of different dimensionality and to slice the data in different ways. Below are two additional examples of this.</p><p><b>2D plot, sliced to visualize populations vs variables</b></p><p>Here we will use similar methods to look at our data in a different way. We will look at a single simulation (param values), and comparing both E and I cells and their underlying variables</p><pre class="codeinput"><span class="comment">% Pull out a 2D MDD object (variables axis is indexed using regular expressions)</span>
mdd2D = mdd(2,2,:,<span class="string">'/v|iNa|iK/'</span>);
mdd2D.printAxisInfo

<span class="comment">% Set up plotting arguments</span>
function_handles = {@xp_subplot_grid,@xp_matrix_basicplot};
dimensions = {{<span class="string">'variables'</span>,<span class="string">'populations'</span>},{<span class="string">'data'</span>}};
function_arguments = {{},{}};

<span class="comment">% Run the plot</span>
close <span class="string">all</span>
figure; mdd2D.recursiveFunc(function_handles,dimensions,function_arguments);
</pre><pre class="codeoutput">Axis Size: [1  1  2  4]
Axis 1: param1 (numeric) -&gt; 10
Axis 2: param2 (numeric) -&gt; 10
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n
</pre><img vspace="5" hspace="5" src="demo_MDD_04.png" alt=""> <p><b>2D plot, sliced to visualize populations vs param1</b></p><p>Here we will repeat our above 3D plot, but instead group populations and param1 into the same set of subplots, and ignore param2. We also swapped in xp_matrix_imagesc for xp_matrix_basicplot, which represents the data using imagesc plots.</p><pre class="codeinput"><span class="comment">% Pull out a 2D MDD object</span>
mdd2D = mdd(:,2,:,<span class="string">'v'</span>);
mdd2D.printAxisInfo

<span class="comment">% Set up plotting arguments</span>
function_handles = {@xp_subplot_grid,@xp_matrix_imagesc};
dimensions = {{<span class="string">'populations'</span>,<span class="string">'param1'</span>},{<span class="string">'data'</span>}};
function_arguments = {{},{}};

<span class="comment">% Run the plot</span>
close <span class="string">all</span>
figure; mdd2D.recursiveFunc(function_handles,dimensions,function_arguments);
</pre><pre class="codeoutput">Axis Size: [3  1  2  1]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 10
Axis 3: populations (cellstr) -&gt; E, I
Axis 4: variables (cellstr) -&gt; v
</pre><img vspace="5" hspace="5" src="demo_MDD_05.png" alt=""> <h2 id="42">Merging two MDD objects</h2><p>MDD also contains methods to perform operations on MDD objects. Here is an example of how two MDD objects can be merged together. For more details on methods like merge, see tutorial_MDD.m</p><pre class="codeinput"><span class="comment">% Slice the dataset one way</span>
close <span class="string">all</span>
mdd1 = mdd(2,:,<span class="string">'E'</span>,<span class="string">'v'</span>);

<span class="comment">% Slice it another way</span>
mdd2 = mdd(:,3,<span class="string">'E'</span>,<span class="string">'v'</span>);
</pre><p>Notice that mdd1 and mdd2 are overlapping at (2,3,1,1). Hence, when we merge, we will set forceMergeBool to true. Without this, it will throw a warning</p><pre class="codeinput"><span class="comment">% Merge with overwrite</span>
mdd_merged = merge(mdd1,mdd2,true);
</pre><p>Now, plot the merged data</p><pre class="codeinput">dimensions = {[1,2],0};
close <span class="string">all</span>; figure; recursiveFunc(mdd_merged,{@xp_subplot_grid,@xp_matrix_imagesc},dimensions);
</pre><img vspace="5" hspace="5" src="demo_MDD_06.png" alt=""> <p>Compare to the original dataset</p><pre class="codeinput">close <span class="string">all</span>; figure; recursiveFunc(mdd(:,:,<span class="string">'E'</span>,<span class="string">'v'</span>),{@xp_subplot_grid,@xp_matrix_imagesc},dimensions);
</pre><img vspace="5" hspace="5" src="demo_MDD_07.png" alt=""> <h2 id="46">Packing MDD dimensions (analogous to cell2mat)</h2><p>MDD object properties include the raw data (usually in the form of a cell array) plus associated metadata. The raw data is an accessible property of <i>mdd</i>:</p><pre class="codeinput"><span class="comment">% Take a slice of mdd</span>
mdd2 = mdd(:,:,:,1);

<span class="comment">% View MDD data</span>
mdd2.data
</pre><pre class="codeoutput">  3&times;3&times;2 cell array
ans(:,:,1) = 
    {1001&times;80 single}    {1001&times;80 single}    {1001&times;80 single}
    {1001&times;80 single}    {1001&times;80 single}    {1001&times;80 single}
    {1001&times;80 single}    {1001&times;80 single}    {1001&times;80 single}
ans(:,:,2) = 
    {1001&times;20 single}    {1001&times;20 single}    {1001&times;20 single}
    {1001&times;20 single}    {1001&times;20 single}    {1001&times;20 single}
    {1001&times;20 single}    {1001&times;20 single}    {1001&times;20 single}
</pre><p>There are several basic MDD operations for acting on data within an MDD object. <i>packDim</i> allows takes a dimension from the MDD object and pushes it into the internal <i>data</i> property. Here we will use it to pack the two cell populations (E and I) into <i>mdd.data</i>, so that they can be plotted simultaneously.</p><pre class="codeinput"><span class="comment">% First, let's average dimension 2 for every cell in _mdd2.data_. This</span>
<span class="comment">% averages all the traces together.</span>
mdd2.data = cellfun(@(x) squeeze(mean(x,2)), mdd2.data, <span class="string">'UniformOutput'</span>, false);
mdd2.data
</pre><pre class="codeoutput">  3&times;3&times;2 cell array
ans(:,:,1) = 
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
ans(:,:,2) = 
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
    {1001&times;1 single}    {1001&times;1 single}    {1001&times;1 single}
</pre><p>Now, pack the 'populations' dimension into <i>mdd2.data</i></p><pre class="codeinput"><span class="comment">% Pack populations into mdd2.data</span>
mdd2 = mdd2.packDim(<span class="string">'populations'</span>);
mdd2.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [3  3  1  1]
Axis 1: param1 (numeric) -&gt; 0, 10, 20
Axis 2: param2 (numeric) -&gt; 5, 10, 15
Axis 3: Dim 3 (numeric) -&gt; 1
Axis 4: variables (cellstr) -&gt; v
</pre><p>The populations property is now missing from mdd2. Instead, mdd2.data contains this information - it is now 1001x2 instead of 10001x1</p><pre class="codeinput"><span class="comment">% View the contents of mdd2.data</span>
mdd2.data
</pre><pre class="codeoutput">ans =
  3&times;3 cell array
    {1001&times;2 single}    {1001&times;2 single}    {1001&times;2 single}
    {1001&times;2 single}    {1001&times;2 single}    {1001&times;2 single}
    {1001&times;2 single}    {1001&times;2 single}    {1001&times;2 single}
</pre><p>Plot the result</p><pre class="codeinput">close <span class="string">all</span>
figure; mdd2.recursiveFunc({@xp_subplot_grid,@xp_matrix_basicplot},{{<span class="string">'param1'</span>,<span class="string">'param2'</span>},{<span class="string">'data'</span>}});
</pre><p>Here, red traces are "I" cells and blue traces are "E" cells.</p><img vspace="5" hspace="5" src="demo_MDD_08.png" alt=""> <h2 id="52">Unpacking MDD dimensions</h2><p>Conversely, MDD dimensions can also be unpacked. Here, we will use the unpackDim method to pull out individual traces and select a few to examine more closely.</p><pre class="codeinput"><span class="comment">% Take a slice of mdd (variables axis is indexed using regular expressions)</span>
mdd2 = mdd(2,2,<span class="string">'E'</span>,<span class="string">'/v|iNa|iK/'</span>);

<span class="comment">% Unpack the 2nd dimension from mdd.data (corresponding to individual</span>
<span class="comment">% traces) and create a new, 5th dimension of mdd to store this.</span>
src = 2; dest = 5;
mdd2=mdd2.unpackDim(src, dest);
mdd2.printAxisInfo
</pre><pre class="codeoutput">Axis Size: [1   1   1   4  80]
Axis 1: param1 (numeric) -&gt; 10
Axis 2: param2 (numeric) -&gt; 10
Axis 3: populations (cellstr) -&gt; E
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n
Axis 5: matrix_dim_2 (numeric) -&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...
</pre><p>We now have a 5th dimension of <i>mdd2</i> corresponding to each of the 80 traces that was originally in <i>mdd2.data</i>. Each of these tracs corresponds to a single cell in the simulation, so we can look at these more closely. Let's select a few.</p><pre class="codeinput"><span class="comment">% Select a few cells. Note we are also renaming axis5.</span>
mdd2.axis(5).name = <span class="string">'Cell Number'</span>;
mdd2 = mdd2(:,:,:,:,[1,3,6,9]);
mdd2.printAxisInfo
</pre><p>For more details on how to rename axes, see tutorial_MDD.m</p><pre class="codeoutput">Axis Size: [1  1  1  4  4]
Axis 1: param1 (numeric) -&gt; 10
Axis 2: param2 (numeric) -&gt; 10
Axis 3: populations (cellstr) -&gt; E
Axis 4: variables (cellstr) -&gt; v, iNa_m, iNa_h, iK_n
Axis 5: Cell Number (numeric) -&gt; 1, 3, 6, 9
</pre><p>Finally, plot the result</p><pre class="codeinput"><span class="comment">% Plot using recursiveFunc</span>
close <span class="string">all</span>
figure; mdd2.recursiveFunc({@xp_subplot_grid,@xp_matrix_basicplot},{{<span class="string">'variables'</span>,<span class="string">'Cell Number'</span>},{<span class="string">'data'</span>}});
</pre><img vspace="5" hspace="5" src="demo_MDD_09.png" alt=""> <h2 id="56">Next steps</h2><p>To start using MDD yourself, see `tutorial_MDD.m`. In particular, this will provide additional details on how to build your own MDD objects and advanced methods to manipulate them.</p><pre class="codeinput"><span class="comment">% Run the following</span>
edit <span class="string">tutorial_MDD.m</span>
</pre><h2 id="57">Summary so far</h2><p>At its core, MDD extends the way cells and matrices are indexed by allowing string labels to be assigned to each dimension of the cell array, similar to how row and column names are assigned to a table (e.g., in Pandas or SQL). MDD objects can then be indexed, sorted, merged, and manipulated according to these labels. (Section: MDD subscripts and indexing)</p><p>Additionally, MDD includes methods for performing operations on high dimensional data. The goal is to modularize the process of working with high dimensional data. Within MDD, functions designed to work on low dimensional data (1 or 2 dimension) can each be assigned to each operate on different dimensions of a higher dimensional object. Chaining several of these functions together can allow the entire high dimensional object to be processed. The advantage of this modular approach is that functions can be easily assigned other dimensions or swapped out entirely, without necessitating substantial code re-writes. (Section: Running functions on MDD objects)</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Multidimensional Dictionary - Demo
% File demonstrating some of the basic capabilities of MDD on a sample
% neuroscience dataset. For full instructions on using MDD, see
% tutorial_MDD.m

%% Overview
% MDD is a MATLAB tool for managing high-dimensional data that often arises
% in scientific data analysis. It can be thoughout of as a MATLAB cell
% array (or matrix) with some additional functionality.

%% Set up paths and formatting

% Format
format compact
format short g

% Check if in MDD folder
if ~exist(fullfile('.','data','sample_data.mat'), 'file')
    error('Should be in MDD folder to run this code.')
end

% Add MDD toolbox to Matlab path if needed
if ~exist('MDD','class')
  addpath(genpath(pwd));
end

%% Load a sample dataset and build an MDD object

% Load some sample simulated data
load('sample_data.mat');
load('sample_data_meta2.mat');

%%%
% The file _sample_data.mat_ contains _dat_, a 4-dimensional cell array:
whos dat

%%
% Each cell in dat contains some neural time series data. For example
dat(1,1,2,1)

%%
% Use this to build an MDD object.

% Construct MDD object
mdd = MDD(dat,axis_vals,axis_names);

%%%
% Note that _axis_vals_ and _axis_names_ contain
% useful metadata, but their details are not important here.


%% What is an MDD object and why use one?
% When working with high-dimensional data, like that cell array _dat_, it's
% often difficult to keep track of what each dimension represents.
% *MDD objects provide a way of organizing and manipulating this 
% information.*

%%% 
% Let's print a summary of the data contained within _mdd_:

% Print object summary
mdd.printAxisInfo

%%
% This tells us several things about our MDD object:
%%%
% * It is a 4-dimensional object with mdd.size = [3,3,2,8]
% * The four axes are titled: param1, param2, populations, and variables
% * This also summarizes the values that each axis takes on, and the corresponding
% data type of those values (numeric or cellstr). For example, the
% 'populations' axis takes on values 'E' and 'I' (for excitatory and
% inhibitory cells, respectively).

%%% 
% An MDD object can be thought of in several ways:
%%%
% * A MATLAB matrix or cell array that can be indexed by using strings and
% regular expressions
% * An N-dimensional table (a table is equivalent to an MDD object in
% 2-dimensions)
% * A map/dictionary that associates multiple keys with a single value



%% MDD subscripts and indexing
% MDD contains several options for how to index data. The most basic method
% is to just index MDD objects like you would index normal Matlab matrices and
% cells. For example:

% Basic indexing
mdd3D = mdd(:,:,1,2:3);
mdd3D.printAxisInfo

%%
% This selects everything from dimensions 1 and 2, the 1st element from dimension 3, and the 2nd and 3rd
% elements from dimension 4. Another way to do this, however, is to
% reference the axis values directly. For example:

% Indexing by string query
mdd3D = mdd(:,:,'E','iNa');
mdd3D.printAxisInfo

%%
% Note that substring matching (based on Matlab's strcmp command)
% was used here to select both iNa_m and iNa_h. However,
% regular expressions can be used as well.
% The "/" denotes to use regular expressions for the search. This command
% picks out all variable names beginning with an "I".

% Indexing by regular expressions
mdd3D = mdd(:,:,'E','/^I/');
mdd3D.printAxisInfo

%%%


%%
% If we only want to specify the values for a single axis, we can use axisSubset.
% This indexes the 'variables' axis for all values containing 'iNa'

% Indexing by axis-value pairs
mdd3D = mdd.axisSubset('variables', 'iNa');
mdd3D.printAxisInfo


%%
% All standard forms of Matlab indexing work as well, including indexing by
% position, linear indexing, and logical indexing.

% Method 1 - Indexing by position
foo1 = mdd(1:3,3,2,8);

% Method 2 - Linear indexing
foo2 = mdd(142:144);      % Take the last 3 entries in the data.

% Method 3 - Logical indexing
ind = false(1,144); ind(142:144) = true;
foo3 = mdd(ind);            % Using logical indexing also produces the same result.

disp(isequal(foo1,foo2,foo3));
clear foo1 foo2 foo3

%%
% The results of all three indexing methods above are the same. For more details
% about indexing methods in Matlab, see: <https://www.mathworks.com/help/matlab/math/array-indexing.html>


%% Advanced indexing methods
% Finally, MDD supports inline queries using the valSubset method. Here are
% two examples.

% Select axis1 values greater than 5, and axis2 equal to 10
mdd3D = mdd.valSubset('>5','==10',:,:);
mdd3D.printAxisInfo

%%

% Select axis1 values between 8 and 11, and axis2 values between 3 and 11
mdd3D = mdd.valSubset('8 < x < 11','3 < x <= 11',:,:);
mdd3D.printAxisInfo



%% Running functions on MDD objects
% The primary purpose of MDD is to make working with high-dimensional data
% more convenient. Traditionally, if you are working with an N-dimensional
% matrix/cell array, you would write a function that takes in that variable and
% knows what to do with each of the N dimensions (usually involving nested
% for loops).
% This function would not work on data with N-1 or N+1 dimensions.

%%%
% MDD takes a different approach. With MDD, you specify function
% handles that operate on lower dimensional data (usually 1D, 2D, or 3D)
% and to "assign" these to specific dimension in your higher dimensional
% MDD object. The MDD method *recursiveFunc* is used for this. Examples
% below will show how recursiveFunc can be used for plotting. But it is not
% limited to this.

%%%
% *Plotting setup*
%%%
% This section can be safely ignored. Here I'm just adding a metadata
% structure to our mdd object, which will be
% used by some of the following plotting commands. This stores some
% additional metadata about the time series in _mdd_. I'm also defining
% a data structure defining how large to make the figures.
meta = struct;
meta.datainfo(1:2) = MDDAxis;
meta.datainfo(1).name = 'time(ms)';
meta.datainfo(1).values = time;
meta.datainfo(2).name = 'cells';
meta.datainfo(2).values = [];
mdd.meta = meta;
clear meta

op.figwidth=0.4;
op.figheight=0.3;


%% Plotting 3D data
% The workhorse of performing functions on MDD objects is *recursiveFunc*.
% Here is an example of how it is used to plot our data.

%%%
% First, we will pull out a 3D subset of the data. Our data consists of 9
% simulations of a neural network, in the form of a 3x3 parameter sweep
% (axes 1 and 2). For each simulation, we have data for the two different
% types of neurons simulated,  excitatory (E) and inhibitory (I) cells. We also have 
% the variables associated with each neuron (for example, membrane
% voltage, ionic currents, etc.). Here, we will only look at the voltage of the neurons.

% Pull out a 3D MDD object with only E cell membrane voltage
mdd3D = mdd(:,1:2,:,'v');
mdd3D.printAxisInfo

%%
% Now, let's run the plot:

% Set up plotting arguments
function_handles = {@xp_handles_fignew,@xp_subplot_grid,@xp_matrix_basicplot};
dimensions = {{'populations'},{'param1','param2'},{'data'}};
function_arguments = {{op},{},{}};	
                                                                
% Run the plot. Note the "+" icons next to each plot allow zooming. 
close all
mdd3D.recursiveFunc(function_handles,dimensions,function_arguments);

%%%
% To break down what's going on here:

%%%
% * _function_handles_ - A cell array of function handles that specify what
% to do with specific dimensions of the data.
% * _dimensions_ - A cell array that tells which dimensions of the data should be assigned to
% which function handles.
% * _function_arguments_ - A cell array that tells what arguments to pass
% to each of the function handles. Here we pass _op_, which tells xp_handles_fignew
% how big to make the figure.
% * There should be 1 entry in _dimensions_ and _function_arguments_ for every
% function handle supplied. (E.g., their lengths should be equal)
%%%
% In this example, the 'populations' dimension of our data (either
% E cells or I cells) is handled by the function _xp_handles_fignew_, which
% creates a new figure for each value along this dimension provided. The dimensions 'param1'
% and 'param2' are handled by xp_subplot_grid, which creates a grid of
% subplots for the parameter sweep. Note that xp_subplot_grid operates on 2D data. Finally, 
% xp_matrix_basicplot creates the actual plots, operating on the time
% series data contained in _mdd.data_

%%%
% Here is the result:

%%
% Note that each of the functions passed to _function_handles_
% is essentially acting on lower-dimensional MDD
% objects. For example, xp_matrix_basicplot operates on 0D data (e.g., a single cell)

% Call xp_matrix_basicplot directly with 0D data (e.g., 
foo = mdd(1,1,2,1);
close all
figure; xp_matrix_basicplot(foo);


%%%
% Similarly, xp_subplot_grid operates on 2D data, but it can only sets up the subplots and cannot
% plot anything. It needs recursiveFunc to chain everything together.


%% Modularization of plotting
% The advantage of recursiveFunc is that the function handles we use can be
% recycled and applied in different contexts. This allows us to work with data of different
% dimensionality and to slice the data in different ways. Below are two
% additional examples of this.


%%%
% *2D plot, sliced to visualize populations vs variables*
%%%
% Here we will use similar methods to look at our data in a different way.
% We will look at a single simulation (param values), and comparing both E
% and I cells and their underlying variables

% Pull out a 2D MDD object (variables axis is indexed using regular expressions)
mdd2D = mdd(2,2,:,'/v|iNa|iK/');
mdd2D.printAxisInfo

% Set up plotting arguments
function_handles = {@xp_subplot_grid,@xp_matrix_basicplot};
dimensions = {{'variables','populations'},{'data'}};
function_arguments = {{},{}};	
                                                                
% Run the plot
close all
figure; mdd2D.recursiveFunc(function_handles,dimensions,function_arguments);

%%
%%%
% *2D plot, sliced to visualize populations vs param1*
%%%
% Here we will repeat our above 3D plot, but instead group populations and
% param1 into the same set of subplots, and ignore param2. We also swapped in xp_matrix_imagesc for
% xp_matrix_basicplot, which represents the data using imagesc plots.

% Pull out a 2D MDD object
mdd2D = mdd(:,2,:,'v');
mdd2D.printAxisInfo

% Set up plotting arguments
function_handles = {@xp_subplot_grid,@xp_matrix_imagesc};
dimensions = {{'populations','param1'},{'data'}};
function_arguments = {{},{}};	
                                                                
% Run the plot
close all
figure; mdd2D.recursiveFunc(function_handles,dimensions,function_arguments);

%% Merging two MDD objects
% MDD also contains methods to perform operations on MDD objects. Here is
% an example of how two MDD objects can be merged together. 
% For more details on methods like merge, see tutorial_MDD.m

% Slice the dataset one way
close all
mdd1 = mdd(2,:,'E','v');

% Slice it another way
mdd2 = mdd(:,3,'E','v');

%%
% Notice that mdd1 and mdd2 are overlapping at (2,3,1,1). Hence, when we
% merge, we will set forceMergeBool to true. Without this, it will throw a
% warning

% Merge with overwrite
mdd_merged = merge(mdd1,mdd2,true);

%%
% Now, plot the merged data
dimensions = {[1,2],0};
close all; figure; recursiveFunc(mdd_merged,{@xp_subplot_grid,@xp_matrix_imagesc},dimensions);

%% 
% Compare to the original dataset
close all; figure; recursiveFunc(mdd(:,:,'E','v'),{@xp_subplot_grid,@xp_matrix_imagesc},dimensions);


%% Packing MDD dimensions (analogous to cell2mat)
% MDD object properties include the raw data (usually in the form of a cell array) plus
% associated metadata. The raw data is an accessible property of _mdd_:

% Take a slice of mdd
mdd2 = mdd(:,:,:,1);

% View MDD data
mdd2.data

%%
% There are several basic MDD operations for acting on data within an MDD
% object. _packDim_ allows takes a dimension from the MDD object and
% pushes it into the internal _data_ property. Here we will use it to pack
% the two cell populations (E and I) into _mdd.data_, so that they can be
% plotted simultaneously.

% First, let's average dimension 2 for every cell in _mdd2.data_. This
% averages all the traces together. 
mdd2.data = cellfun(@(x) squeeze(mean(x,2)), mdd2.data, 'UniformOutput', false);
mdd2.data

%%
% Now, pack the 'populations' dimension into _mdd2.data_

% Pack populations into mdd2.data
mdd2 = mdd2.packDim('populations');
mdd2.printAxisInfo

%%
% The populations property is now missing from mdd2. Instead, mdd2.data
% contains this information - it is now 1001x2 instead of 10001x1

% View the contents of mdd2.data
mdd2.data


%%
% Plot the result
close all
figure; mdd2.recursiveFunc({@xp_subplot_grid,@xp_matrix_basicplot},{{'param1','param2'},{'data'}});

%%%
% Here, red traces are "I" cells and blue traces are "E" cells.

%% Unpacking MDD dimensions
% Conversely, MDD dimensions can also be unpacked. Here, we will use the
% unpackDim method to pull out individual traces and select a few to
% examine more closely. 

% Take a slice of mdd (variables axis is indexed using regular expressions)
mdd2 = mdd(2,2,'E','/v|iNa|iK/');

% Unpack the 2nd dimension from mdd.data (corresponding to individual
% traces) and create a new, 5th dimension of mdd to store this.
src = 2; dest = 5;
mdd2=mdd2.unpackDim(src, dest);
mdd2.printAxisInfo

%%
% We now have a 5th dimension of _mdd2_ corresponding to each of the 80 traces
% that was originally in _mdd2.data_.
% Each of these tracs corresponds to a single cell in the simulation, so we
% can look at these more closely. Let's select a few.

% Select a few cells. Note we are also renaming axis5.
mdd2.axis(5).name = 'Cell Number';
mdd2 = mdd2(:,:,:,:,[1,3,6,9]);
mdd2.printAxisInfo

%%%
% For more details on how to rename axes, see tutorial_MDD.m

%%
% Finally, plot the result

% Plot using recursiveFunc
close all
figure; mdd2.recursiveFunc({@xp_subplot_grid,@xp_matrix_basicplot},{{'variables','Cell Number'},{'data'}});

%% Next steps
% To start using MDD yourself, see `tutorial_MDD.m`. In particular, this
% will provide additional details on how to build your own MDD objects and
% advanced methods to manipulate them.

% Run the following
edit tutorial_MDD.m

%% Summary so far
% At its core, MDD
% extends the way cells and matrices are indexed by allowing string labels to be
% assigned to each dimension of the cell array, similar to how row and column
% names are assigned to a table (e.g., in Pandas or SQL). MDD objects can then be indexed,
% sorted, merged, and manipulated
% according to these labels. 
% (Section: MDD subscripts and indexing)
%%%
% Additionally, MDD includes methods for
% performing operations on high dimensional data. The goal is to modularize
% the process of working with high dimensional data. Within MDD, functions
% designed to work on low dimensional data
% (1 or 2 dimension) can each be assigned to each operate on different
% dimensions of a higher dimensional object. Chaining several of these
% functions together can allow the entire high dimensional object to be
% processed. The advantage of this modular approach is that functions can be easily
% assigned other dimensions or swapped out entirely, without necessitating
% substantial code re-writes.
% (Section: Running functions on MDD objects)


##### SOURCE END #####
--></body></html>